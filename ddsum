#!/usr/bin/python
#
# Copyright (c) 2011 Jeff Fisher <guppy@ddsum.com>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
#   * Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#   * Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#   * The names of contributors to this software may not be used to endorse or
#     promote products derived from this software without specific prior written
#     permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
import os.path
import sys

try:
	import hashlib
except ImportError:
	class compat_hashlib(object):
		algorithms = ('md5', 'sha1')

		def new(self, name):
			if name in ("md5", "MD5"):
				import md5
				return md5.new()
			elif name in ("sha1", "SHA1"):
				import sha
				return sha.new()
			else:
				raise ValueError("unsupported hash type")

	hashlib = compat_hashlib()
else:
	# hashlib in Python 2.7+ provides a list of algorithms
	if not hasattr(hashlib, 'algorithms'):
		hashlib.algorithms = ("md5", "sha1", "sha224", "sha256", "sha384", "sha512")

def get_hashfunc(name):
	try:
		return hashlib.new(name)
	except ValueError:
		print >>sys.stderr, "%s: unsupported hash type" % sys.argv[0], name
		print >>sys.stderr, "\nSupported algorithms:", ", ".join(hashlib.algorithms)
		print >>sys.stderr, " ** Additional algorithms may also be available depending upon the OpenSSL library that Python uses on your platform."
		sys.exit(1)
	
def check_hashes(fd):
	total = failed = 0

	while True:
		try:
			line = fd.readline()
		except KeyboardInterrupt:
			sys.exit(0)

		if not line:
			break

		try:
			digest, filename = line.strip().split(" ", 1)
		except:
			continue

		open_mode = "r"

		if filename[0] == "*":
			open_mode = "rb"
			filename = filename[1:]
		elif filename[0] == " ":
			filename = filename[1:]
		else:
			continue

		digest_name = digest_lengths.get(len(digest), None)
		
		if digest_name is None:
			continue

		hashfunc = get_hashfunc(digest_name)

		if filename == "-":
			infile = sys.stdin
		else:	
			try:
				infile = open(os.path.realpath(filename), open_mode)
			except Exception, e:
				print >>sys.stderr, "%s:" % sys.argv[0], e
				continue

		total += 1

		while True:
			try:
				data = infile.read(opts.bytes)
			except KeyboardInterrupt:
				sys.exit(0)

			if not data:
				break

			hashfunc.update(data)
	
		if infile.name != "<stdin>":
			infile.close()

		print "%s:" % filename,

		if hashfunc.hexdigest() == digest:
			print "OK %s" % digest_name
		else:
			print "FAILED %s" % digest_name
			failed += 1
			
	if total == 0:
		print >>sys.stderr, "%s: %s: no properly formatted checksum lines found" % (sys.argv[0], fd.name)

	if fd.name != "<stdin>":
		fd.close()

	return {"total": total, "failed": failed}

if __name__ == "__main__":
	from optparse import OptionParser
	parser = OptionParser(usage="usage: %prog [OPTION] [infile [outfile]]", version="%prog 8", add_help_option=False)
	parser.add_option("--help", action="help")
	parser.add_option("-b", "--blocksize", action="store", type="int", dest="bytes", default=4096, help="read and write BYTES bytes at a time")
	parser.add_option("-c", "--check", action="store_true", dest="check", default=False, help="read sums from the FILEs and check them")
	parser.add_option("-h", "--hash", action="append", dest="hash", help="FIPS secure hash algorithm(s) to use (default: sha1)")
	parser.add_option("-n", "--no-data", action="store_true", dest="nodata", default=False, help="do not output the source data")
	(opts, args) = parser.parse_args()

	largs = len(args)

	if opts.check:
		if opts.hash is not None:
			digest_lengths = {get_hashfunc(opts.hash[0]).digest_size * 2: opts.hash[0]}
		else:
			digest_lengths = {}
			for digest in hashlib.algorithms:
				digest_lengths[hashlib.new(digest).digest_size * 2] = digest

		total = 0
		failed = 0

		if largs == 0:
			args = ["-",]

		for f in args:
			if f == "-":
				ret = check_hashes(sys.stdin)
			else:
				try:
					fd = open(f, "r")
				except Exception, e:
					print >>sys.stderr, "%s:" % sys.argv[0], e
					continue
				else:
					ret = check_hashes(fd)

			total += ret["total"]
			failed += ret["failed"]
				
		if failed > 0:
			print >>sys.stderr, "%s: WARNING: %d of %d computed checksum did NOT match" % (sys.argv[0], failed, total)
			sys.exit(1)
	
		sys.exit(0)

	if largs > 2 or (opts.nodata and largs > 1):
		parser.print_usage()
		sys.exit(1)

	if opts.hash is None:
		opts.hash = ['sha1',]

	hashfuncs = []

	for tmp in opts.hash:
		for digest_name in tmp.split(","):
			hashfuncs.append((digest_name, get_hashfunc(digest_name)))

	filename = "-"
	infile = sys.stdin
	outfile = sys.stdout

	if largs != 0 and args[0] != "-":
		try:
			infile = open(args[0], "rb")
		except Exception, e:
			print >>sys.stderr, "%s:" % sys.argv[0], e
			sys.exit(1)
	
		filename = args[0]
	
	if not opts.nodata and largs == 2 and args[1] != "-":
		try:
			outfile = open(args[1], "wb")
		except Exception, e:
			print >>sys.stderr, "%s:" % sys.argv[0], e
			sys.exit(1)

		if args[1] != "-":
			filename = args[1]

	while True:
		try:
			data = infile.read(opts.bytes)
		except KeyboardInterrupt:
			sys.exit(0)

		if not data:
			break

		for func in hashfuncs:
			func[1].update(data)
		
		if not opts.nodata:
			outfile.write(data)

	if infile.name != "<stdin>":
		infile.close()

	if outfile.name != "<stdout>":
		outfile.close()

	for func in hashfuncs:
		if len(hashfuncs) > 1:
			print >>sys.stderr, "# %s" % func[0].upper()

		print >>sys.stderr, "%s *%s" % (func[1].hexdigest(), filename)

