#!/usr/bin/python

import sys
import os.path

try:
	import hashlib
except ImportError:
	class compat_hashlib(object):
		algorithms = ('md5', 'sha1')

		def new(self, name):
			if name in ("md5", "MD5"):
				import md5
				return md5.new()
			elif name in ("sha1", "SHA1"):
				import sha
				return sha.new()
			else:
				raise ValueError("unsupported hash type")

	hashlib = compat_hashlib()
else:
	# hashlib in Python 2.7+ provides a list of algorithms
	if not hasattr(hashlib, 'algorithms'):
		hashlib.algorithms = ("md5", "sha1", "sha224", "sha256", "sha384", "sha512")

def get_hashfunc(name):
	try:
		return hashlib.new(name)
	except ValueError:
		print >>sys.stderr, "%s: unsupported hash type" % sys.argv[0], name
		print >>sys.stderr, "\nSupported algorithms:", ", ".join(hashlib.algorithms)
		print >>sys.stderr, " ** Additional algorithms may also be available depending upon the OpenSSL library that Python uses on your platform."
		sys.exit(1)
	
def check_hashes(fd, init_hashfunc, digest_name=None):
	total = failed = 0

	for line in fd:
		try:
			digest, filename = line.strip().split(" ", 1)
		except:
			continue

		open_mode = "r"

		if filename[0] == "*":
			open_mode = "rb"
			filename = filename[1:]
		elif filename[0] == " ":
			filename = filename[1:]
		else:
			continue

		if init_hashfunc is None:
			digest_name = digest_lengths.get(len(digest), None)
		
			if digest_name is None:
				continue

			hashfunc = get_hashfunc(digest_name)
		else:
			hashfunc = init_hashfunc.copy()

		if filename == "-":
			infile = sys.stdin
		else:	
			try:
				infile = open(os.path.realpath(filename), open_mode)
			except Exception, e:
				print >>sys.stderr, "%s:" % sys.argv[0], e
				continue

		total += 1

		while True:
			data = infile.read(opts.bytes)

			if not data:
				break

			hashfunc.update(data)
	
		if infile.name != "<stdin>":
			infile.close()

		print "%s:" % filename,

		if hashfunc.hexdigest() == digest:
			print "OK %s" % digest_name
		else:
			print "FAILED %s" % digest_name
			failed += 1
			
	if total == 0:
		print >>sys.stderr, "%s: %s: no properly formatted checksum lines found" % (sys.argv[0], fd.name)

	if fd.name != "<stdin>":
		fd.close()

	return {"total": total, "failed": failed}

if __name__ == "__main__":
	from optparse import OptionParser
	parser = OptionParser(usage="usage: %prog [OPTION] [infile [outfile]]", version="%prog 7", add_help_option=False)
	parser.add_option("--help", action="help")
	parser.add_option("-b", "--blocksize", action="store", type="int", dest="bytes", default=4096, help="read and write BYTES bytes at a time")
	parser.add_option("-c", "--check", action="store_true", dest="check", default=False, help="read sums from the FILEs and check them")
	parser.add_option("-h", "--hash", action="append", dest="hash", help="FIPS secure hash algorithm(s) to use (default: sha1)")
	parser.add_option("-n", "--no-data", action="store_true", dest="nodata", default=False, help="do not output the source data")
	(opts, args) = parser.parse_args()

	largs = len(args)

	if opts.check:
		if opts.hash is not None:
			hashfunc = get_hashfunc(opts.hash[0])
			digest_name = opts.hash[0]
		else:
			hashfunc = digest_name = None
			digest_lengths = {}
			for digest in hashlib.algorithms:
				digest_lengths[hashlib.new(digest).digest_size * 2] = digest

		total = 0
		failed = 0

		if largs == 0:
			args = ["-",]

		for f in args:
			if f == "-":
				ret = check_hashes(sys.stdin, hashfunc, digest_name)
			else:
				try:
					fd = open(f, "r")
				except Exception, e:
					print >>sys.stderr, "%s:" % sys.argv[0], e
					continue
				else:
					ret = check_hashes(fd, hashfunc, digest_name)

			total += ret["total"]
			failed += ret["failed"]
				
		if failed > 0:
			print >>sys.stderr, "%s: WARNING: %d of %d computed checksum did NOT match" % (sys.argv[0], failed, total)
			sys.exit(1)
	
		sys.exit(0)

	if largs > 2 or (opts.nodata and largs > 1):
		parser.print_usage()
		sys.exit(1)

	if opts.hash is None:
		opts.hash = ['sha1',]

	hashfuncs = []

	for tmp in opts.hash:
		for digest_name in tmp.split(","):
			hashfuncs.append((digest_name, get_hashfunc(digest_name)))

	filename = "-"

	if largs != 0 and args[0] != "-":
		try:
			sys.stdin = open(args[0], "rb")
		except Exception, e:
			print >>sys.stderr, "%s:" % sys.argv[0], e
			sys.exit(1)
	
		filename = args[0]
	
	if not opts.nodata and largs == 2 and args[1] != "-":
		try:
			sys.stdout = open(args[1], "wb")
		except Exception, e:
			print >>sys.stderr, "%s:" % sys.argv[0], e
			sys.exit(1)

		if args[1] != "-":
			filename = args[1]

	while True:
		data = sys.stdin.read(opts.bytes)

		if not data:
			break

		for func in hashfuncs:
			func[1].update(data)
		
		if not opts.nodata:
			sys.stdout.write(data)

	for func in hashfuncs:
		if len(hashfuncs) > 1:
			print >>sys.stderr, "# %s" % func[0].upper()

		print >>sys.stderr, "%s *%s" % (func[1].hexdigest(), filename)

